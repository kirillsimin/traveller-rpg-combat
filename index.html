<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Traveller RPG Combat Un-Balancer</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Orbitron', sans-serif;
      background-color: #0e0e0e;
      color: #e0e0e0;
      padding: 20px;
    }

    h1 {
      text-align: center;
      margin-bottom: 20px;
      color: #00ffea;
      text-shadow: 0 0 10px #00ffea, 0 0 20px #00ffea;
    }

    .subtitle {
      font-weight: 400;
      font-size: 1rem;
      margin-bottom: 20px;
      text-align: center;
    }

    .instructions {
      margin-bottom: 20px;
      margin-left: 20px;
    }

    .simulation-controls {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
      margin: 20px 0;
    }

    .multi-sim {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
    }

    .simulation-controls label {
      margin-right: 5px;
      font-size: 1rem;
    }

    .simulation-controls input[type="number"] {
      width: 100px;
      padding: 5px;
      border-radius: 4px;
      border: 1px solid #333;
      background-color: #2e2e2e;
      color: #e0e0e0;
      margin-right: 10px;
    }

    .simulation-controls button {
      width: 200px;
      padding: 10px 15px;
      border: none;
      border-radius: 4px;
      background-color: #00ffea;
      color: #0e0e0e;
      font-weight: bold;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }

    .simulation-controls button:hover {
      background-color: #00d1c1;
    }

    .container {
      display: flex;
      justify-content: space-between;
      gap: 20px;
      flex-wrap: wrap;
    }

    .column {
      width: 48%;
      background-color: #1e1e1e;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 0 15px rgba(0, 255, 234, 0.2);
    }

    .column h2 {
      margin-bottom: 10px;
      color: #00ffe3;
      text-shadow: 0 0 5px #00ffe3;
    }

    input {
      background-color: #2e2e2e;
      color: #e0e0e0;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 10px;
      table-layout: fixed;
    }

    th,
    td {
      padding: 8px;
      border: 1px solid #333;
      text-align: center;
      word-wrap: break-word;
    }

    th {
      background-color: #2e2e2e;
      color: #00ffea;
    }

    tr:nth-child(even) {
      background-color: #2a2a2a;
    }

    tr:hover {
      background-color: #383838;
    }

    button {
      width: 100%;
      padding: 10px;
      margin-top: 5px;
      background-color: #00ffea;
      border: none;
      border-radius: 4px;
      color: #0e0e0e;
      font-weight: bold;
      cursor: pointer;
      transition: background-color 0.3s ease;
      box-shadow: 0 0 5px #00ffea;
    }

    button:hover {
      background-color: #00d1c1;
    }

    .remove-btn {
      background-color: #ff4c4c;
      color: #fff;
      padding: 5px 10px;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.3s ease;
      box-shadow: 0 0 5px #ff4c4c;
    }

    .remove-btn:hover {
      background-color: #e04343;
    }

    .results {
      margin-top: 20px;
      background-color: #1e1e1e;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 0 15px rgba(0, 255, 234, 0.2);
    }

    .results h2 {
      color: #00ffea;
      text-shadow: 0 0 5px #00ffea;
      margin-bottom: 10px;
      text-align: center;
    }

    .results p,
    .results h3 {
      margin-bottom: 10px;
      color: #e0e0e0;
    }

    .scrollable {
      max-height: 200px;
      overflow-y: auto;
      background: #2e2e2e;
      padding: 10px;
      border-radius: 6px;
      border: 1px solid #444;
      color: #e0e0e0;
    }

    pre {
      font-family: 'Courier New', Courier, monospace;
      color: #a0ffa0;
    }

    @media (max-width: 768px) {
      .column {
        width: 100%;
        margin-bottom: 20px;
      }

      .container {
        flex-direction: column;
      }

      th,
      td {
        font-size: 0.7rem;
      }

      .multi-sim {
        flex-direction: column;
        align-items: center;
      }

      .multi-sim label,
      .multi-sim input,
      .multi-sim button {
        width: 100%;
        text-align: center;
      }
    }
  </style>
</head>

<body>
  <h1>Traveller RPG Combat Un-Balancer</h1>
  <p class="subtitle">Space is Hell... War is even worse...</p>
  <p>
    This is a naive Traveller RPG combat calculator. It does not account for missed shots, multiple weapons, dodging,
    taking cover, etc.
    Its primary purpose is to ensure your enemies don't get annihilated in the first round.
  </p>
  <h3>Instructions:</h3>
  <ul class="instructions">
    <li><strong>HP:</strong> Enter the total sum of END + DEX + STR.</li>
    <li><strong>Damage:</strong> Enter it in the form of 1D, 2D+3, 3D-2, etc...</li>
    <li><strong>Rate of Fire:</strong> Number of times to roll damage per turn (default: 1).</li>
    <li><strong>DM to Attack:</strong> Dice modifier for attack rolls. Each attack rolls 2d6 + DM, hits on 8+ (default:
      0).</li>
  </ul>
  <div class="container">
    <div class="column" id="playersColumn">
      <h2>Players</h2>
      <table id="playersTable">
        <thead>
          <tr>
            <th>HP</th>
            <th>Armor</th>
            <th>Damage</th>
            <th>AP</th>
            <th>Rate of Fire</th>
            <th>DM to Attack</th>
            <th>Remove</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
      <button onclick="addCharacter('playersTable')">Add Player</button>
    </div>

    <div class="column" id="enemiesColumn">
      <h2>Enemies</h2>
      <table id="enemiesTable">
        <thead>
          <tr>
            <th>HP</th>
            <th>Armor</th>
            <th>Damage</th>
            <th>AP</th>
            <th>Rate of Fire</th>
            <th>DM to Attack</th>
            <th>Remove</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
      <button onclick="addCharacter('enemiesTable')">Add Enemy</button>
    </div>
  </div>

  <div class="simulation-controls">
    <div class="multi-sim">
      <label for="simulationCount">Number of Simulations:</label>
      <input id="simulationCount" type="number" value="10000" min="1">
      <button onclick="runSimulations()">Run Simulations</button>
    </div>
  </div>

  <div class="results" id="resultsArea"></div>

  <script>
    // ---- Utilities ----
    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[array[i], array[j]] = [array[j], array[i]]; }
    }

    function addCharacter(tableId) {
      const table = document.getElementById(tableId).getElementsByTagName('tbody')[0];
      const row = table.insertRow();
      const fields = ['hp', 'armor', 'damage', 'ap', 'rof', 'dm'];
      fields.forEach(() => {
        const cell = row.insertCell();
        const input = document.createElement('input');
        input.type = (fields[cell.cellIndex] === 'damage') ? 'text' : 'number';
        input.required = true;
        let placeholder = fields[cell.cellIndex].toUpperCase();
        if (fields[cell.cellIndex] === 'rof') placeholder = 'ROF';
        if (fields[cell.cellIndex] === 'dm') placeholder = 'DM';
        input.placeholder = placeholder;
        input.style.width = '90%';
        if (fields[cell.cellIndex] === 'rof') {
          input.value = '1'; // Default rate of fire to 1
          input.min = '1';
        }
        if (fields[cell.cellIndex] === 'dm') {
          input.value = '0'; // Default DM to 0
        }
        cell.appendChild(input);
      });
      const removeCell = row.insertCell();
      const removeBtn = document.createElement('button');
      removeBtn.textContent = 'X'; removeBtn.className = 'remove-btn';
      removeBtn.onclick = () => table.deleteRow(row.rowIndex - 1);
      removeCell.appendChild(removeBtn);
    }

    // Parse like "2D+1", returns {dice, mod}
    function parseDamageSpec(damageStr) {
      const regex = /^(\d+)[dD]\s*([+-]\s*\d+)?$/;
      const match = (damageStr || '').trim().match(regex);
      if (!match) return { dice: 0, mod: 0 };
      const dice = parseInt(match[1], 10) || 0;
      const mod = match[2] ? parseInt(match[2].replace(/\s+/g, ''), 10) : 0;
      return { dice, mod };
    }


    // Roll actual damage for a given spec (sum of d6 plus mod)
    function rollDamage(spec) {
      let total = spec.mod;
      for (let i = 0; i < spec.dice; i++) total += 1 + Math.floor(Math.random() * 6);
      return total;
    }

    // Roll 2d6 + DM and check if attack hits (8+)
    function rollAttack(dm) {
      const roll1 = 1 + Math.floor(Math.random() * 6);
      const roll2 = 1 + Math.floor(Math.random() * 6);
      const total = roll1 + roll2 + dm;
      return total >= 8;
    }


    function collectCharacters(tableId) {
      const table = document.getElementById(tableId);
      const rows = table.getElementsByTagName('tbody')[0].rows;
      const characters = [];
      for (let row of rows) {
        const cells = row.cells;
        const hp = parseFloat(cells[0].firstChild.value) || 0;
        const armor = parseFloat(cells[1].firstChild.value) || 0;
        const damageStr = cells[2].firstChild.value || '0';
        const ap = parseFloat(cells[3].firstChild.value) || 0;
        const rof = parseInt(cells[4].firstChild.value) || 1;
        const dm = parseInt(cells[5].firstChild.value) || 0;
        const spec = parseDamageSpec(damageStr);
        characters.push({ hp, armor, damageSpec: spec, ap, rof, dm });
      }
      return characters;
    }

    // ---- Multiple Simulations (now with rolled damage) ----
    function runSimulations() {
      const simulationCount = Math.max(1, parseInt(document.getElementById('simulationCount').value) || 1);
      const playersBase = collectCharacters('playersTable');
      const enemiesBase = collectCharacters('enemiesTable');
      if (playersBase.length === 0 || enemiesBase.length === 0) { alert('Please add at least one player and one enemy.'); return; }

      let totalPlayersDiedSum = 0, totalEnemiesDiedSum = 0;
      let playersEliminationCount = 0, enemiesEliminationCount = 0;
      let totalDamageToPlayers = 0, totalDamageToEnemies = 0;
      const roundsPerRun = [];

      for (let run = 0; run < simulationCount; run++) {
        let playersAlive = playersBase.map(p => ({ ...p, hp: p.hp }));
        let enemiesAlive = enemiesBase.map(e => ({ ...e, hp: e.hp }));
        let totalPlayersDied = 0, totalEnemiesDied = 0; let turn = 0;

        while (playersAlive.length > 0 && enemiesAlive.length > 0) {
          turn++;
          const initiative = playersAlive.map(p => ({ type: 'player', actor: p }))
            .concat(enemiesAlive.map(e => ({ type: 'enemy', actor: e })));
          shuffle(initiative);

          for (const combatant of initiative) {
            if (combatant.type === 'player') {
              if (enemiesAlive.length === 0) break;
              if (!playersAlive.includes(combatant.actor)) continue;
              const attacker = combatant.actor;
              const targetIndex = Math.floor(Math.random() * enemiesAlive.length);
              const target = enemiesAlive[targetIndex];
              const effectiveArmor = Math.max(target.armor - attacker.ap, 0);

              // Roll damage multiple times based on rate of fire
              for (let shot = 0; shot < attacker.rof; shot++) {
                if (target.hp <= 0) break; // Target already dead

                // Roll to hit first
                if (rollAttack(attacker.dm)) {
                  const rolled = rollDamage(attacker.damageSpec);
                  const netDamage = Math.max(rolled - effectiveArmor, 0);
                  totalDamageToEnemies += netDamage;
                  target.hp -= netDamage;
                  if (target.hp <= 0) {
                    enemiesAlive.splice(targetIndex, 1);
                    totalEnemiesDied++;
                    break; // Target eliminated, stop shooting
                  }
                }
                // If attack misses, no damage is dealt
              }
            } else {
              if (playersAlive.length === 0) break;
              if (!enemiesAlive.includes(combatant.actor)) continue;
              const attacker = combatant.actor;
              const targetIndex = Math.floor(Math.random() * playersAlive.length);
              const target = playersAlive[targetIndex];
              const effectiveArmor = Math.max(target.armor - attacker.ap, 0);

              // Roll damage multiple times based on rate of fire
              for (let shot = 0; shot < attacker.rof; shot++) {
                if (target.hp <= 0) break; // Target already dead

                // Roll to hit first
                if (rollAttack(attacker.dm)) {
                  const rolled = rollDamage(attacker.damageSpec);
                  const netDamage = Math.max(rolled - effectiveArmor, 0);
                  totalDamageToPlayers += netDamage;
                  target.hp -= netDamage;
                  if (target.hp <= 0) {
                    playersAlive.splice(targetIndex, 1);
                    totalPlayersDied++;
                    break; // Target eliminated, stop shooting
                  }
                }
                // If attack misses, no damage is dealt
              }
            }
          }
        }

        totalPlayersDiedSum += totalPlayersDied; totalEnemiesDiedSum += totalEnemiesDied;
        if (playersAlive.length === 0) playersEliminationCount++;
        if (enemiesAlive.length === 0) enemiesEliminationCount++;
        roundsPerRun.push(turn);
      }

      // Stats for rounds
      const minRounds = Math.min(...roundsPerRun);
      const maxRounds = Math.max(...roundsPerRun);
      const avgRounds = roundsPerRun.reduce((a, b) => a + b, 0) / roundsPerRun.length;

      const avgPlayersDied = totalPlayersDiedSum / simulationCount;
      const avgEnemiesDied = totalEnemiesDiedSum / simulationCount;

      const totalPlayerUnits = playersBase.length * simulationCount;
      const totalEnemyUnits = enemiesBase.length * simulationCount;

      const avgDamageToPlayersPerUnit = totalDamageToPlayers / totalPlayerUnits;
      const avgDamageToEnemiesPerUnit = totalDamageToEnemies / totalEnemyUnits;

      const resultsArea = document.getElementById('resultsArea');
      resultsArea.innerHTML = `
        <h2>Aggregate Simulation Results (over ${simulationCount} runs)</h2>
        <table>
          <thead>
            <tr><th colspan="3">Rounds Until One Side Eliminated</th></tr>
            <tr><th>Min</th><th>Average</th><th>Max</th></tr>
          </thead>
          <tbody>
            <tr><td>${minRounds}</td><td>${avgRounds.toFixed(2)}</td><td>${maxRounds}</td></tr>
          </tbody>
        </table>

        <table>
          <thead>
            <tr><th>Players</th><th>Enemies</th></tr>
          </thead>
          <tbody>
            <tr>
              <td><strong>Avg. Died:</strong> ${avgPlayersDied.toFixed(2)}</td>
              <td><strong>Avg. Died:</strong> ${avgEnemiesDied.toFixed(2)}</td>
            </tr>
            <tr>
              <td><strong>Avg. Dmg Taken / unit:</strong> ${avgDamageToPlayersPerUnit.toFixed(2)}</td>
              <td><strong>Avg. Dmg Taken / unit:</strong> ${avgDamageToEnemiesPerUnit.toFixed(2)}</td>
            </tr>
            <tr>
              <td><strong>Elimination %:</strong> ${(playersEliminationCount / simulationCount * 100).toFixed(2)}%</td>
              <td><strong>Elimination %:</strong> ${(enemiesEliminationCount / simulationCount * 100).toFixed(2)}%</td>
            </tr>
          </tbody>
        </table>
      `;
    }

  </script>
</body>

</html>